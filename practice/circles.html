<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Section 1, Module 1: Math â€” Circles (Practice)</title>

  <!-- Bluebook-style quiz layout -->
  <link rel="stylesheet" href="/assets/css/quiz.css" />
</head>
<body>
  <div class="app">
    <!-- Header -->
    <div class="header" role="banner">
      <div>
        <div class="title" id="sectionTitle">
          Section 1, Module 1: Math â€” Circles (Practice)
        </div>
        <button class="directions" aria-label="Directions">Directions â–¾</button>
      </div>

      <!-- Added a quick link to My Progress -->
      <div style="display:flex;align-items:center;gap:12px">
        <a href="/my-progress.html" style="color:#cfe3ff;text-decoration:none;font-size:14px;">My Progress</a>
        <div class="timer" aria-live="polite">
          <b id="timeLeft">30:00</b>
          <button id="toggleTimer" class="btn ghost" aria-pressed="false">Hide</button>
        </div>
      </div>

      <div aria-hidden="true"></div>
    </div>

    <!-- Practice banner + ticks -->
    <div class="ticks">THIS IS A PRACTICE TEST</div>
    <div class="dashrow" id="dashrow"></div>

    <!-- ONE-COLUMN QUESTION CARD -->
    <div class="qwrap">
      <article class="qcard" id="qcard">
        <header class="qtop">
          <div class="qbadge" id="qbadge">1</div>
          <div class="qdash" aria-hidden="true"></div>
          <button id="flagTop" class="flagbtn" aria-pressed="false">
            <span class="flagicon"></span><span id="flagLabel">Mark for review</span>
          </button>
          <button id="elimToggle" class="elimbtn" aria-pressed="false" title="Eliminate answers">
            <span class="elimicon" aria-hidden="true"></span> Eliminate
          </button>
        </header>

        <h2 class="qtitle" id="qtitle">Question text</h2>
        <div class="choices" id="choices" role="radiogroup" aria-label="Choices"></div>
        <div class="hint" id="elimHint" style="display:none">
          Eliminate mode is on â€” click an answer to gray it out. Click again to restore.
        </div>
      </article>
    </div>

    <!-- Review page (optional mid-test) -->
    <section class="check-wrap" id="checkPage" aria-label="Check Your Work">
      <h1 class="check-head">Check Your Work</h1>
      <p class="check-sub">
        On test day, you wonâ€™t be able to move on to the next module until time expires.
      </p>
      <div class="check-card">
        <div class="check-row">
          <div>Section 1, Module 1: Math â€” Circles Questions</div>
          <div class="check-leg">
            <span>
              <span class="box"
                    style="width:16px;height:16px;border:2px dashed #2b3350;border-radius:4px;
                           display:inline-block;margin-right:6px"></span>
              Unanswered
            </span>
            <span>
              <span class="flag"
                    style="width:12px;height:12px;background:var(--flag);
                           display:inline-block;margin-right:6px"></span>
              For Review
            </span>
          </div>
        </div>
        <div class="grid-nums" id="checkGrid"></div>
      </div>
    </section>
  </div>

  <!-- Bottom rail -->
  <div class="rail" role="contentinfo">
    <div class="rail-inner">
      <div class="progress" id="progress"></div>
      <button class="center-pill" id="centerPill" aria-haspopup="dialog" aria-expanded="false">
        <div class="pill-flag" id="pillFlag" style="display:none"></div>
        <span id="pillText">Question 1 of 6</span><span class="caret">â–¾</span>
      </button>
      <div class="rail-left">
        <button id="btnBack" class="btn nav">Back</button>
      </div>
      <div class="rail-actions">
        <button id="btnNext" class="btn nav primary">Next</button>
        <button id="btnFinish" class="btn nav primary" style="display:none">End &amp; Score</button>
      </div>
    </div>
  </div>

  <!-- Review popover -->
  <div class="popover" id="popover" role="dialog" aria-modal="false"
       aria-label="Question Navigator">
    <button class="close" id="popClose" aria-label="Close">Ã—</button>
    <div class="title">Section 1, Module 1: Math â€” Circles Questions</div>
    <div class="legend">
      <span>ğŸ“ Current</span>
      <span><span class="box"></span> Unanswered</span>
      <span><span class="flag"></span> For Review</span>
    </div>
    <div class="grid" id="popGrid"></div>
    <button class="go-review" id="goReview">Go to Review Page</button>
  </div>

  <!-- Quiz config only; logic lives in /assets/quiz-engine.js -->
  <script>
    window.examConfig = {
      topicId: "circles",
      sectionTitle: "Section 1, Module 1: Math â€” Circles (Practice)",
      storageKey: "dsa:quiz:circles",
      summaryKey: "dsa:summary:circles",
      // where quiz-engine.js should send them after Finish
      summaryHref: "circles-summary.html",
      timeLimitSec: 30 * 60,
      questions: [
        {
          id: "q1",
          prompt: "A circle has radius 5 cm. What is its circumference?",
          choices: ["10Ï€ cm","25Ï€ cm","5Ï€ cm","50Ï€ cm"],
          answerIndex: 0,
          explanation: "Use C = 2Ï€r. With r = 5, C = 2Â·Ï€Â·5 = 10Ï€ cm."
        },
        {
          id: "q2",
          prompt: "If a circleâ€™s area is 49Ï€, what is its radius?",
          choices: ["3","7","14","24.5"],
          answerIndex: 1,
          explanation: "Area A = Ï€rÂ². If A = 49Ï€, then rÂ² = 49 and r = 7."
        },
        {
          id: "q3",
          prompt: "A circle passes through (0,0) and (0,6) with center at (0,3). What is its equation?",
          choices: [
            "(x âˆ’ 0)Â² + (y âˆ’ 3)Â² = 9",
            "(x âˆ’ 3)Â² + (y âˆ’ 0)Â² = 9",
            "(x âˆ’ 3)Â² + (y âˆ’ 3)Â² = 6",
            "(x âˆ’ 0)Â² + (y âˆ’ 6)Â² = 3"
          ],
          answerIndex: 0,
          explanation:
            "Center (0,3); radius is the distance to (0,0): âˆš[(0âˆ’0)Â²+(0âˆ’3)Â²] = 3. Equation: (xâˆ’0)Â² + (yâˆ’3)Â² = 3Â² = 9."
        },
        {
          id: "q4",
          prompt: "For r = 10 and Î¸ = Ï€/3, what is the arc length s?",
          choices: ["10Ï€/3","20Ï€/3","30Ï€","10","Ï€/3"],
          answerIndex: 0,
          explanation: "Arc length s = rÎ¸ (Î¸ in radians). So s = 10Â·(Ï€/3) = 10Ï€/3."
        },
        {
          id: "q5",
          prompt: "Sector area for r = 6 and Î¸ = Ï€/2 is",
          choices: ["9Ï€","18Ï€","36Ï€","3Ï€"],
          answerIndex: 1,
          explanation: "Sector area = (1/2) rÂ² Î¸ = (1/2)Â·36Â·(Ï€/2) = 18Ï€."
        },
        {
          id: "q6",
          prompt: "If the diameter is 18, the area is",
          choices: ["81Ï€","36Ï€","18Ï€","9Ï€"],
          answerIndex: 0,
          explanation: "Diameter 18 â‡’ r = 9. Area = Ï€rÂ² = Ï€Â·81 = 81Ï€."
        }
      ]
    };
  </script>

  <!-- Recorder: stores test results to localStorage (and has pushToServer stub) -->
  <script src="/assets/js/quiz-recorder.js" defer></script>

  <!-- Core quiz engine (existing) -->
  <script src="/assets/quiz-engine.js" defer></script>

  <!-- Integration: capture finished practice tests and record them to My Progress -->
  <script>
    (function () {
      // Wait until DOM + engine initialize
      function whenReady(fn) {
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
          fn();
        } else {
          document.addEventListener('DOMContentLoaded', fn);
        }
      }

      whenReady(function () {
        const finishBtn = document.getElementById('btnFinish');
        if (!finishBtn) return;

        // Called when we detect quiz finished data available
        function recordFromSummaryData(summary, answersData) {
          try {
            if (!window.DreamSchoolRecorder || !window.DreamSchoolRecorder.recordTestResult) {
              console.warn('DreamSchoolRecorder not available; skipping record.');
              return;
            }

            // Attempt to extract common fields from summary object
            const totalCandidates = [
              summary && summary.total,
              summary && summary.numQuestions,
              summary && summary.questions,
              (Array.isArray(answersData) && answersData.length),
              (window.examConfig && window.examConfig.questions && window.examConfig.questions.length)
            ];
            const scoreCandidates = [
              summary && summary.score,
              summary && summary.correct,
              summary && summary.numCorrect,
              summary && summary.num_right,
              summary && summary.points,
            ];

            // Determine total and score
            const total = (function () {
              for (const v of totalCandidates) {
                if (typeof v === 'number' && !isNaN(v)) return v;
                if (Array.isArray(v)) return v.length;
              }
              return (window.examConfig && window.examConfig.questions && window.examConfig.questions.length) || 0;
            })();

            let score = (function () {
              for (const v of scoreCandidates) {
                if (typeof v === 'number' && !isNaN(v)) return v;
              }
              // Fallback: compute from stored answers compared to examConfig
              if (Array.isArray(answersData) && window.examConfig && Array.isArray(window.examConfig.questions)) {
                let c = 0;
                for (let i = 0; i < window.examConfig.questions.length; i++) {
                  const q = window.examConfig.questions[i];
                  const ans = answersData[i];
                  if (ans == null) continue;
                  // answersData could be objects like {qid:..., answer: index} or just index
                  const selectedIndex = (typeof ans === 'number') ? ans : (ans && (ans.selected || ans.answer || ans.choice) || ans.index);
                  if (typeof selectedIndex === 'number' && q.answerIndex === Number(selectedIndex)) c++;
                }
                return c;
              }
              return null;
            })();

            if (score === null) score = 0;

            // duration: try common fields
            let durationSeconds = null;
            if (summary && typeof summary.durationSeconds === 'number') durationSeconds = summary.durationSeconds;
            else if (summary && typeof summary.timeSpent === 'number') durationSeconds = summary.timeSpent;
            else if (summary && typeof summary.seconds === 'number') durationSeconds = summary.seconds;

            // Build answer detail array if possible
            let answers = [];
            if (Array.isArray(answersData)) {
              // Normalize items to { qid, answer, correct }
              answers = answersData.map((a, idx) => {
                const q = (window.examConfig && window.examConfig.questions && window.examConfig.questions[idx]) || {};
                let sel = null;
                if (typeof a === 'number') sel = a;
                else if (a && typeof a === 'object') sel = a.selected ?? a.answer ?? a.choice ?? a.index ?? null;
                const correct = typeof sel === 'number' && typeof q.answerIndex === 'number' ? (Number(sel) === Number(q.answerIndex)) : undefined;
                return { qid: q.id || idx + 1, answer: sel, correct };
              });
            }

            const record = {
              score: Number(score),
              total: Number(total),
              durationSeconds: durationSeconds != null ? Number(durationSeconds) : 0,
              category: (window.examConfig && window.examConfig.sectionTitle) ? window.examConfig.sectionTitle : 'Circles (Practice)',
              answers: answers
            };

            window.DreamSchoolRecorder.recordTestResult(record);
            // Optionally push to server in background
            if (window.DreamSchoolRecorder.pushToServer) {
              window.DreamSchoolRecorder.pushToServer(record).catch(() => {});
            }
          } catch (err) {
            console.error('Failed to record practice test result:', err);
          }
        }

        // Try to read summaryKey & storageKey out of examConfig
        const summaryKey = (window.examConfig && window.examConfig.summaryKey) || 'dsa:summary:circles';
        const storageKey = (window.examConfig && window.examConfig.storageKey) || 'dsa:quiz:circles';

        // Helper: read summary JSON if present
        function tryReadSummary() {
          try {
            const raw = localStorage.getItem(summaryKey);
            return raw ? JSON.parse(raw) : null;
          } catch (e) { return null; }
        }

        // Helper: read answers object/array saved by engine
        function tryReadAnswers() {
          try {
            const raw = localStorage.getItem(storageKey);
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            // The engine might store an object with answers: [] or an array itself.
            if (Array.isArray(parsed)) return parsed;
            if (parsed && Array.isArray(parsed.answers)) return parsed.answers;
            // some formats: map of qid->choiceIndex -> convert to array
            if (parsed && typeof parsed === 'object') {
              // attempt to return array in same order as examConfig.questions
              const qs = (window.examConfig && window.examConfig.questions) || [];
              const arr = qs.map(q => {
                // try keys q.id, q1 etc
                const key = q.id;
                if (parsed[key] !== undefined) return parsed[key];
                // fallback to positional array stored inside object under "responses"
                if (Array.isArray(parsed.responses)) return parsed.responses[qs.indexOf(q)];
                return null;
              });
              return arr;
            }
            return null;
          } catch (e) { return null; }
        }

        // Polling helper: after finish button clicked, wait up to timeout for summary to appear
        function waitForSummaryAndRecord(timeoutMs = 2500) {
          const start = Date.now();
          (function poll() {
            const summary = tryReadSummary();
            const answers = tryReadAnswers();
            if (summary || answers) {
              // If summary exists, prefer summary fields; always pass answers if available
              recordFromSummaryData(summary || {}, answers || []);
              return;
            }
            if (Date.now() - start > timeoutMs) {
              // Last-ditch: try compute from answers alone
              const fallbackAnswers = tryReadAnswers();
              if (fallbackAnswers) {
                recordFromSummaryData({}, fallbackAnswers);
              } else {
                // nothing to record
                console.warn('No summary or answers found to record after finish.');
              }
              return;
            }
            setTimeout(poll, 120);
          })();
        }

        // Attach a capture handler to the finish button. This runs alongside the engine.
        finishBtn.addEventListener('click', function () {
          // Give engine first crack at writing summary to localStorage, then capture it.
          // The polling handles synchronous and slightly-asynchronous writes.
          setTimeout(() => waitForSummaryAndRecord(3000), 10);
        });

        // Also capture when the engine writes directly to the summaryKey (in case it doesn't go through finish button)
        // Monkey-patch localStorage.setItem to detect writes to summaryKey (non-invasive and safe fallback)
        try {
          const originalSetItem = Storage.prototype.setItem;
          Storage.prototype.setItem = function (k, v) {
            try {
              originalSetItem.apply(this, [k, v]);
              if (String(k) === String(summaryKey) || String(k) === String(storageKey)) {
                // Small async delay so other handlers can finish
                setTimeout(() => {
                  const summary = tryReadSummary();
                  const answers = tryReadAnswers();
                  if (summary || answers) {
                    recordFromSummaryData(summary || {}, answers || []);
                  }
                }, 10);
              }
            } catch (e) {
              // If any error occurs, ensure original still works
              try { originalSetItem.apply(this, [k, v]); } catch (_) {}
            }
          };
        } catch (err) {
          // ignore if we can't patch (some environments restrict prototype changes)
        }
      });
    })();
  </script>
</body>
</html>
